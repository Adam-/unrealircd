#line 0 "_MODULE__autogenerated.cc"
#include <list>

class _MODULE__Module
{
        public:
	static const char *getVersion();
	static const char *getCopyright();
	static const char *getName()
	{
		return "_MODULE_";
	}

        typedef bool (*onInit_hooker)(bool reloading);

        static void onInit(bool reloading)
        {
                std::list<onInit_hooker>::iterator it = onInit_hookers().begin();

                while (it != onInit_hookers().end())
                {
                        if ((*(*it))(reloading))
                        {
                                it++;
                        }
                        else break;
                }
        }
        static std::list<onInit_hooker>& onInit_hookers()
        {
                static std::list<onInit_hooker> hookers;
                return hookers;
        }
        static void onInit_registerHooker(onInit_hooker hooker)
        {
                onInit_hookers().push_front(hooker);
        }
        static void onInit_deregisterHooker(onInit_hooker hooker)
        {
                onInit_hookers().remove(hooker);
        }

        typedef bool (*onUnload_hooker)();

        static void onUnload()
        {
                std::list<onUnload_hooker>::iterator it = onUnload_hookers().begin();

                while (it != onUnload_hookers().end())
                {
                        if ((*(*it))())
                        {
                                it++;
                        }
                        else break;
                }
        }
        static std::list<onUnload_hooker>& onUnload_hookers()
        {
                static std::list<onUnload_hooker> hookers;
                return hookers;
        }
        static void onUnload_registerHooker(onUnload_hooker hooker)
        {
                onUnload_hookers().push_front(hooker);
        }
        static void onUnload_deregisterHooker(onUnload_hooker hooker)
        {
                onUnload_hookers().remove(hooker);
        }

        typedef bool (*onReload_hooker)();

        static void onReload()
        {
                std::list<onReload_hooker>::iterator it = onReload_hookers().begin();

                while (it != onReload_hookers().end())
                {
                        if ((*(*it))())
                        {
                                it++;
                        }
                        else break;
                }
        }
        static std::list<onReload_hooker>& onReload_hookers()
        {
                static std::list<onReload_hooker> hookers;
                return hookers;
        }
        static void onReload_registerHooker(onReload_hooker hooker)
        {
                onReload_hookers().push_front(hooker);
        }
        static void onReload_deregisterHooker(onReload_hooker hooker)
        {
                onReload_hookers().remove(hooker);
        }

}; 

extern "C" void _MODULE__init(int isReload);
extern "C" void _MODULE__reload();
extern "C" void _MODULE__unload();
